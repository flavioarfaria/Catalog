/*
 * Copyright (C) 2022 Flavio Faria
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.flaviofaria.catalog.gradle.codegen.writer

import com.flaviofaria.catalog.gradle.codegen.ResourceEntry
import com.flaviofaria.catalog.gradle.codegen.ResourceType
import com.flaviofaria.catalog.gradle.codegen.toCamelCase
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeName
import java.io.File

abstract class CatalogWriter<T : ResourceEntry>(
  private val packageName: String,
  protected val resourceType: ResourceType,
) {

  open val resourcesReceiverClass = ClassName(
    "com.flaviofaria.catalog.runtime.resources",
    resourceType.receiverType,
  )
  open val composeReceiverClass = ClassName(
    "com.flaviofaria.catalog.runtime.compose",
    resourceType.receiverType,
  )
  private val contextClass = ClassName("android.content", "Context")
  private val fragmentClass = ClassName("androidx.fragment.app", "Fragment")
  open val rClass = ClassName(packageName, "R")

  open val composableClass = ClassName("androidx.compose.runtime", "Composable")
  open val readOnlyComposableClass = ClassName("androidx.compose.runtime", "ReadOnlyComposable")

  fun write(
    resources: List<T>,
    sourceSetName: String,
    codegenDestination: File,
    generateResourcesExtensions: Boolean,
    generateComposeExtensions: Boolean,
  ) {
    val file = FileSpec.builder(packageName, resourceType.receiverType)
      .addFileHeaders(sourceSetName)
      .apply {
        resources.forEach { resource ->
          addResourceProperty(resourceType.resourceGroup, resource, generateComposeExtensions)
          if (generateResourcesExtensions) {
            buildExtensionMethod(this, resource, contextClass, asComposeExtensions = false)
            buildExtensionMethod(this, resource, fragmentClass, asComposeExtensions = false)
          }
          if (generateComposeExtensions) {
            buildExtensionMethod(this, resource, contextReceiver = null, asComposeExtensions = true)
          }
        }
      }.build()
    file.writeTo(codegenDestination)
  }

  private fun FileSpec.Builder.addFileHeaders(
    sourceSetName: String,
  ): FileSpec.Builder {
    val capitalizedSourceSetName = sourceSetName.replaceFirstChar {
      it.titlecase()
    }
    return addFileComment(
      """Auto-generated by Catalog. DO NOT EDIT.
      |https://github.com/flavioarfaria/Catalog""".trimMargin(),
    ).addAnnotation(
      AnnotationSpec.builder(JvmName::class)
        .addMember("%S", "${resourceType.receiverType}$capitalizedSourceSetName")
        .useSiteTarget(AnnotationSpec.UseSiteTarget.FILE)
        .build(),
    ).addAnnotation(
      AnnotationSpec.builder(Suppress::class)
        .addMember("%S", "NOTHING_TO_INLINE")
        .useSiteTarget(AnnotationSpec.UseSiteTarget.FILE)
        .build(),
    )
  }

  private fun FileSpec.Builder.addResourceProperty(
    resourceGroup: String,
    resource: ResourceEntry,
    asComposeExtensions: Boolean,
  ) {
    addProperty(
      PropertySpec.builder(resource.name.toCamelCase(), Int::class)
        .apply { resource.docs?.let(::addKdoc) }
        .receiver(
          if (asComposeExtensions) {
            composeReceiverClass
          } else {
            resourcesReceiverClass
          }
        )
        .getter(
          FunSpec.getterBuilder()
            .addModifiers(KModifier.INLINE)
            .addStatement("return %T.$resourceGroup.%L", rClass, resource.name)
            .build()
        )
        .build()
    )
  }

  abstract fun buildExtensionMethod(
    builder: FileSpec.Builder,
    resource: T,
    contextReceiver: TypeName?,
    asComposeExtensions: Boolean,
  ): FileSpec.Builder
}
